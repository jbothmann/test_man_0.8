from tkinter import *
from tkinter import messagebox
from tkinter import filedialog
from tkSelectLabel import * #Local Import
from datetime import datetime
from struct import *
from time import sleep

import flask
import flask.json
import serial
import types
import json
import copy
import os
import string
import random
import tkTheme #Local Import
import tkinter.font
import threading, queue

version = "0.8"

serTimeout = 0.1

numberOfData = 32
numberOfControls = 32

#base64 encoded bytestring which contains the favicon
encoded_string = b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAASQSURBVHhe7ZpdbBRVFMf/K61AgFKxfegmoA9SC0E0JGCIBqg0giH6Ag+KL2BEjU3E+PEkbJAHNDHVaAL4EYUH06A+iAFMSSG8WROFAm2wHyDGpppAhLZJW+luOZ7LnAnb7el054tpnPml/5x77+69e8+ZO/djpikC+C++3CU2tiQBEBtbkgCIjS1JAMTGliQAYmNLEgCxsSUJgNjYcmdOg6WlwPp1wIYNQHU1h32afMA/ffOmpBmTtntDJp3XtdFRSTCm3P7M2MI2bG61l/e9N94EenqsvI00FZ7q1hJ1dhCN5qLV0SNq/8IdAS+9COzdx1c84jstmwWWLQMu/CYFtwmvZ2tWTw3nDQcPqM4bwhkBd/M939oK1NRIQYQMDAAPcj+uXJGCsYRzebZtmxrOGxoaJnTeEPwImDcP6OywbNT09loXYmhYCsYT/AjI7Jgazht2vOPovCHYEWDW+PPnrHXfiWPHLOVyUhAQ5eXAqlW851gPtJ0Hlj/K3k3inglAYPrhe30NzlfbOaLp0/X6QenhpUQrV+qfFSi4ADxRqzucr6FBq3Na/YgUTABKSohaz+hO5+v17Xr9CBVMALZu0R3OVy5LVD5Xrx+h/E+Cs2cDHReAqrQUOGAOIqd/9Tn5cXd7/wb27we6L0qZD+xIeFZmp37Fw9ZAnzXvaH1yIX8jIF3FV583PbNmScEdpu868AgfcgqPuC7wtxHavTs65w3l9wA7eePlA+8jIM33/B+XgWn2w42IuNjNh51FknGP9xGwaWP0zhsGByXhDe8BqF0jCY+Yjh89AjQ28ra1beyjLDc0HpKER8wt4EktP+mzczH67luiysqx7VUvJPrqS6KRG3odTd1dvrfV3gOw7kmi69f0jjmp4QOiVEpv0+jxx4h6/tTrFuqZp/U2XMjfMjhnDrBiBW+GilwJRrJAU5P10zZVvJS+8jJw6hTQ0gLcGAGWPmQ9UXKiuZlPfU9Jxgd2JCJRaSnR6V9uX9E+HlHfHCLalRl7pQs1PES0qEZv06WiDcBzz+oOTqaPPtTb86BwngkWS12dJFxw9Sqw613J+Ke4ACxZAiyYL5kAqbhXEi7IZID+fsn4Z/JJ0Gx2fubJafFiYN9e3vt3WuWjsm7fGkgOa7h5DWbW+JMn+BT3lxQK9fXAJx9LpgjOngWW86Trdc+gYd8LE+r5zfp96FYD/USb+Z7Pb9ssh5s2EjX9SPTvsF7PVm7EWiLz6wcg5wDMmEF0+ZLeIa96/z1r9i/8rYoKou2vEWXZUa1e49fj6wQg5wC8/ZbeGb9qbyN6YSvRgvlEM2cSzS0jquWzffNx/fvX/iFKp/U++tTEc0BlBdDVBZSVSUFImNfe5v1hKiUFCvWvAp9+LplgmXgVMC8VwnbeYCZZJ+fNgemzLyQTPPoIWPgA0N4OlJRIQUSYU+JqPnUGuOwVoo+APXuid/4EL5treaMUovOG8SPg/vuAAwedh2VYmH9k+P0ScPgwH5qOW9NUyPg7Df4PiPYsMAVIAiA2tiQBEBtbkgCIjS1JAMTGliQAYmNLEgCxMQX4DxvJZiayMybCAAAAAElFTkSuQmCC'



#procedure to be taken when attempting to exit the program, which will prompt a save
def exitProgram():
    response = messagebox.askyesnocancel("Power Tools Test Manager", "Save before closing Test Manager?", parent=root.focus_get())
    if not response is None:
        if response:
            saveSession()
        root.destroy()
        poll.destroy()




#class Test, holds all information about one test
class Test:
    #a separate tuple array to keep track of all comments in chronological order
    allComments = []

    #station status constants
    NORMAL = "In Progress"
    IN_PROGRESS = NORMAL
    PAUSED = "Paused"
    STOPPED = "Stopped"
    OFFLINE = "Offline"

    #A list of all urls that have been generated by generateUrl()
    urlsInUse = []
    
    #static function that generates a unique url for each test
    #urls are a string of len 16, made up of random letters and numbers.
    #if the function generates a url that has already been registered, it will recursively create a new url
    #all urls should be appended to a main address
    def generateUrl():
        url = ''.join(random.choice(string.ascii_letters+string.digits) for ii in range(16))
        if url not in Test.urlsInUse:
            Test.urlsInUse.append(url)
        else:
            url = generateUrl()
        return url


    #Constructor which creates a test with expandable data
    def __init__(self, address=-1, name="[test name]", serial="[serial number]", data=None, controls=None):
        global dataFrame
        try:
            self.testNum = int(address) #Slave PLC address
        except ValueError as e:
            self.testNum = -1

        self.url = Test.generateUrl() #unique identifying string used by the API

        self.name = name #title of the station, should include name of unit and test type, should be identifiably unique
        self.serial = serial #subtitle for the station
        self.status = "Offline"
        self.data = [] #data variables, a len 32 list of 4-lists, including a string defining the datum, a string defining the units, the number datum, and a boolean which determines if the datum is used
        
        #repair passed data if it is unsuitable or absent
        if not isinstance(data, list):
            data = [
                ["Cycles", "", 0, True]
                ]
        #handle given data, making sure that each entry is a proper 4-list   
        for ii in range(numberOfData):
            self.data.append(["", "", 0, False])
            if ii < len(data):
                if isinstance(data[ii], list):
                    if len(data[ii]) > 0:
                        if isinstance(data[ii][0], str):
                            self.data[ii][0] = data[ii][0] #set datum name, string
                            self.data[ii][3] = True #assume the data is used if it has a name
                            
                    if len(data[ii]) > 1:
                        if isinstance(data[ii][1], str):
                            self.data[ii][1] = data[ii][1] #set datum unit, string
                           
                    #setting data value not accepted
                    #if len(data[ii]) > 2:
                    #    self.data[ii][2] = data[ii][2] #set datum value, currently accepts any value type
                           
                    if len(data[ii]) > 3:
                        if isinstance(data[ii][3], bool):
                            self.data[ii][3] = data[ii][3] #set show datum, boolean

                elif isinstance(data[ii], dict):
                    if "name" in data[ii]:
                        if isinstance(data[ii]["name"], str):
                            self.data[ii][0] = data[ii]["name"] #set datum name, string
                            self.data[ii][3] = True #assume the data is used if it has a name

                    if "units" in data[ii]:
                        if isinstance(data[ii]["units"], str):
                            self.data[ii][1] = data[ii]["units"] #set datum unit, string

                    #setting data value not accepted
                    # if "float" in data[ii]:
                    #     if isinstance(data[ii]["float"], float):
                    #         self.data[ii][2] = data[ii]["float"] #set value, python float

                    if "show" in data[ii]:
                        if isinstance(data[ii]["show"], bool):
                            self.data[ii][3] = data[ii]["show"] #set show datum, boolean
                           
                elif isinstance(data[ii], str):
                    self.data[ii][0] = data[ii] #set datum name if only a string name is given
                    self.data[ii][3] = True #assume the data is used if it has a name

        #repair passed label if it is unsuitable or absent
        self.controls = [] #controls, a len 32 list of 2-lists, including a string name which communicates what each control does, and a boolean value
        if not isinstance(controls, list):
            controls = []

        #handle given labels, ensuring that each entry is a proper 2-list string
        for ii in range(numberOfControls):
            self.controls.append(["", False])
            if ii < len(controls):
                if isinstance(controls[ii], list):
                    if len(controls[ii]) > 0:
                        if isinstance(controls[ii][0], str):
                            self.controls[ii][0] = controls[ii][0] #set control label, string

                if isinstance(controls[ii], dict):
                    if "name" in controls[ii]:
                        if isinstance(controls[ii]["name"], str):
                            self.controls[ii][0] = controls[ii]["name"] #set control label, string

                elif isinstance(controls[ii], str):
                    self.controls[ii][0] = controls[ii] #set control label if only a string name is given     

        self.comments = [] #tuple list of additional notes, including error modes and manual measurements
        #contains a string representing time of report, and a string phrase description
        self.r = None #row that the test is drawn to in the main viewer
        self.c = None #column that the test is drawn to in the main viewer
        #boolean which allows the test to be hidden
        self.showTest = True
        
        #initialize labelWidgetFrame and its children.  This widget will show the title of the station and a small edit button
        self.labelWidgetFrame = Frame()
        self.stationNumLabel = Label(self.labelWidgetFrame)
        self.stationNumLabel.grid(row=0, column=0)
        self.button0 = Button(self.labelWidgetFrame, text="\U00002699", command=lambda: editTests(self.testNum))
        self.button0.grid(row=0, column=1)

        #initialize frame, which will be used to store the widgets
        self.frame = LabelFrame(dataFrame, labelwidget=self.labelWidgetFrame, padx=5, pady=5, relief=RIDGE)

        #initialize dataLabel, which will be used to display info #TODO: fix selections not working properly when the contents are being modified
        self.dataLabel = SelectLabel(self.frame)
        #initialize statusIndicator, which will be used to visually represent the status of the test
        self.statusIndicator = Label(self.frame)

        #initialize two buttons, which will be used for test control
        self.button1 = Button(self.frame, width=14)
        self.button2 = Button(self.frame, width=14)

        #plot each widget into the frame
        self.dataLabel.grid(row=1)
        self.statusIndicator.grid(row=2, pady=2)
        #draw control buttons
        #self.button0.grid(row=0, column=1, sticky=E, pady=0)
        self.button1.grid(row=4, pady=2)
        self.button2.grid(row=5)

        self.periodicCall() #begin periodic updating
    
       
    #Test.draw, draws the information to the screen based on internal info
    #parameters are positional info which will determine where it is drawn
    def draw(self, r, c):
        global locked
        global dataFrame
        self.r = r
        self.c = c

        #apply theme to all widgets
        T.apply([self.labelWidgetFrame, self.stationNumLabel, self.button0, self.frame, self.statusIndicator, self.button1, self.button2])

        #apply non-contrast theme to SelectLabel() widget dataLabel
        self.dataLabel.config(bg=T.theme.bg, fg=T.theme.fg, selectbackground=T.theme.selectbg, selectforeground=T.theme.selectfg, font=(T.family, T.size))
        self.stationNumLabel.config(text="Station " + str(self.testNum), font=(T.family, T.size+2))
        self.frame.grid(row=r, column=c, pady=3, padx=3) #regrid the frame

        #add correct information to widgets
        self.updateLabel()
        

    def redraw(self):
        self.draw(self.r, self.c)
        
    #updateLabel, reconfigures the widgets within the gui frame to accurately represent and control the incoming data
    def updateLabel(self):
        global root
        self.dataLabel.config(text=self.toString())
        if self.status == Test.NORMAL:
            self.statusIndicator.config(text="\U00002B24   In Progress", fg="green")
            self.button1.config(text="Pause", command=lambda poll=poll, theTest=self: poll.pause(theTest), state=NORMAL)
            self.button2.config(text="More Controls", command=lambda: openControls(self.testNum), state=NORMAL)
        elif self.status == Test.PAUSED:
            self.statusIndicator.config(text="\U00002B24   Paused", fg=T.theme.fg)
            self.button1.config(text="Resume", command=lambda poll=poll, theTest=self: poll.resume(theTest), state=NORMAL)
            self.button2.config(text="More Controls", command=lambda: openControls(self.testNum), state=NORMAL)
        elif self.status == Test.STOPPED:
            self.statusIndicator.config(text="\U00002B24   Stopped", fg="orange")
            self.button1.config(text="Pause", state=DISABLED)
            self.button2.config(text="More Controls", command=lambda: openControls(self.testNum), state=NORMAL)
        elif self.status == Test.OFFLINE:
            self.statusIndicator.config(text="\U00002B24   Offline", fg="red")
            self.button1.config(text="Pause", state=DISABLED)
            self.button2.config(text="More Controls", state=DISABLED)
        else: #in default state:
            self.statusIndicator.config(text=None)
            self.button1.config(text="Pause", state=DISABLED)
            self.button2.config(text="More Controls", state=DISABLED)
            
        if locked:
            self.button0.config(text="\U00002699", state=DISABLED)
            self.button1.config(text="PAUSE LOCKED", state=DISABLED)
            self.button2.config(text="CONTROLS LOCKED", state=DISABLED)
        else:
            self.button0.config(text="\U00002699", state=NORMAL)

        #reconfigure the minimum size of the main window
        root.update_idletasks()
        root.minsize(width=max(root.winfo_reqwidth(),400), height=max(root.winfo_reqheight(),300))

    #This method calls itself periodically to update the contents of the main station display widget
    def periodicCall(self): 
        if self.showTest == True:
            self.updateLabel()
        root.after(1000, self.periodicCall) #schedule next call, in ms

    def set(self, newData):
        for ii in range(len(newData)):
            self.data[ii][2] = newData[ii]

    #four methods for updating the test's status, which will also update the datalabel:
    def setNormal(self):
        if not self.status == Test.NORMAL:
            self.status = Test.NORMAL

    def setPaused(self):
        if not self.status == Test.PAUSED:
            self.status = Test.PAUSED

    def setStopped(self): #unused state
        if not self.status == Test.STOPPED:
            self.status = Test.STOPPED

    def setOffline(self):
        if not self.status == Test.OFFLINE:
            self.status = Test.OFFLINE

    #appends a new comment to the test
    def addComment(self, phrase):
        self.comments.append((datetime.now().strftime("%m/%d/%Y, %H:%M:%S :"), phrase))
        Test.allComments.append((self.name, datetime.now().strftime("%m/%d/%Y, %H:%M:%S :"), phrase))     

    #Test.toString, will return a text representation of the data in the Test object
    def toString(self):
        string = self.name+"\n"+self.serial+"\n"
        for ii in range(numberOfData):
            if self.data[ii][3]:
                string += str(self.data[ii][0])+": "+f'{self.data[ii][2]:.2f}'+" "+str(self.data[ii][1])+"\n"
        return string.rstrip()

    def toStringPlusComments(self):
        return (str(self.toString()) + "\n" + str(self.getComments())).rstrip()

    def getComments(self):
        string = ""
        for time, phrase in self.comments:
            string += time + "\n" + phrase + "\n" 
        return string.rstrip()

    def getAllComments(self):
        string = ""
        for title, time, phrase in Test.allComments:
            string += title + "\n" + time + "\n" + phrase + "\n"
        return string.rstrip()

    def setControlLabels(self, newLabels):
        for ii in range(len(newLabels)):
            if isinstance(newLabels[ii], str):
                self.controls[ii][0] = newLabels[ii]

    def setControlStatus(self, newStatus):
        for ii in range(len(newStatus)):
            if isinstance(newStatus[ii], bool):
                self.controls[ii][1] = newStatus[ii]
            



#Default named values when creating a new test using the gui dialog #TODO: is this needed?
defaultValNames = [
    "Cycles",
    "Time Elapsed",
    "Torque",
    "Speed",
    "Current Draw",
    "Voltage",
    "Temperature",
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""
    ]

#application functions block
                                  
def saveSession():
    try:
        #open *.JSON file using system dialog
        file = filedialog.asksaveasfile(parent=root, initialdir = "/", title = "Save As", filetypes = (("JSON Files","*.json"),), defaultextension="*.*")
    except OSError as e: #catch errors relating to opening the file
        messagebox.showerror("Power Tools Test Manager", "Could not save file", parent=root.focus_get())
    else:
        if not file is None:
            testList = []
            for oo in tests:
                testList.append({
                    "number":oo.testNum, 
                    "title":oo.name, 
                    "subtitle":oo.serial, 
                    "data":[{
                        "name":oo.data[ii][0],
                        "units":oo.data[ii][1],
                        "show":oo.data[ii][3]
                        } for ii in range(numberOfData)],

                    "controls":[{"name":oo.controls[ii][0]} for ii in range(numberOfControls)]
                    })
            json.dump(testList, file)
    finally:
        if not file is None:
            file.close()
        
def openSession():
    try:
        #open *.JSON file using system dialog
        file = filedialog.askopenfile(parent=root, initialdir = "/", title = "Open", filetypes = (("JSON Files","*.json"),))
    except OSError as e: #catch errors relating to opening the file
        messagebox.showerror("Power Tools Test Manager", "Could not open file", parent=root.focus_get())
    else:
        if not file is None:
            try:
                newTests = parseJSONsession(json.load(file)) #call helper function
                tests.extend(newTests)
            except Exception as e: #This mostly handles when file isn't correct JSON
                messagebox.showerror("Power Tools Test Manager", "Incorrect File Type", parent=root.focus_get())
    finally:
        if not file is None:
            file.close()
        update()

#helper function for openSession, that robustly parses the loaded JSON session representation and returns a list of Test objects
def parseJSONsession(s):
    if not isinstance(s, list): #If the json object is not a list, turn it into one for simpler parsing
        s = [s]

    newTests = [] #add new Test objects to this list to be returned
    for oo in s:
        kwargs = {} #enumerate kwargs that will be passed to the Test object initializer
        if "number" in oo:
            if isinstance(oo["number"], int):
                kwargs["address"] = oo["number"]

        if "title" in oo:
            if isinstance(oo["title"], str):
                kwargs["name"] = oo["title"]

        if "subtitle" in oo:
            if isinstance(oo["subtitle"], str):
                kwargs["serial"] = oo["subtitle"]

        #data and controls arguments are not parsed thoroughly here, because they are already handled by the Test object initializer
        if "data" in oo: 
            if isinstance(oo["data"], list):
                kwargs["data"] = oo["data"]

        if "controls" in oo:
            if isinstance(oo["controls"], list):
                kwargs["controls"] = oo["controls"]

        newTests.append(Test(**kwargs))

    return newTests
        
def connect(): #TODO: test com connection more thoroughly ?
    #setup the new menu
    tl = T.apply(Toplevel())
    tl.title('Connect')
    tl.grab_set() #make window modal
    tl.focus_set()

    currentPortSelection = 0

    COMframe = T(LabelFrame(tl, text="COM Ports", padx=5, pady=5, relief=RIDGE))

    APIframe = T(LabelFrame(tl, text="API Server", padx=5, pady=5, relief=RIDGE))

    #Add ports to dropdown menu, refresh interactable widgets
    def getCOMs():
        if poll.is_open():
            COMportHint.config(text="Connected to %s" % poll.ser.port)
            disconnectCOMButton.config(state=NORMAL)
        else:
            COMportHint.config(text="Not Connected")
            disconnectCOMButton.config(state=DISABLED)

        select(0)  #reset dropdown menu
        dropdown.menu.delete(0, END)
        for ii in range(256): #Scan all serial ports, and include all available ports in portList
            try:
                s = serial.Serial('COM%s' % (ii + 1))
                s.close()
                dropdown.menu.add_command(label='COM%s' % (ii + 1), command = lambda x=ii+1: select(x))
            except (OSError, serial.serialutil.SerialException):
                pass

    #select is called every time a new option is chosen from the dropdown menu.  It updates the window to the new state
    def select(portSelection):
        nonlocal currentPortSelection
        currentPortSelection = portSelection
        if currentPortSelection > 0 and currentPortSelection <= 256:
            dropdown.config(text='COM%s' % (currentPortSelection)+" \U000025BC")
            connectCOMButton.config(state=NORMAL)                       
        else:
            dropdown.config(text="Select a COM port \U000025BC")
            connectCOMButton.config(state=DISABLED)

    #connects the program to the chosen COM port
    def connectCOM():
        nonlocal currentPortSelection
        if currentPortSelection > 0 and currentPortSelection <= 256:
            poll.change_port(currentPortSelection)
            poll.open()
        update()
        getCOMs()

    def disconnectCOM():
        poll.close()
        update()
        getCOMs()

    def connectAPI(): #TODO: implement this
        APIhint.config(text="Now serving on 0.0.0.0:%s" % APIportEntry.get())
        connectAPIButton.config(state=DISABLED)
        disconnectAPIButton.config(state=NORMAL)

    def disconnectAPI():
        APIhint.config(text="Not Serving")
        connectAPIButton.config(state=NORMAL)
        disconnectAPIButton.config(state=DISABLED)

    #Create interactable elements for COM port setup

    #draw port chooser dropdown
    dropdown = T.apply(Menubutton(COMframe, width=17, relief=RAISED))
    dropdown.menu = T.apply(Menu(dropdown, tearoff=0))
    dropdown["menu"] = dropdown.menu
    dropdown.grid(row=0, column=0, padx=5, pady=5)

    #hint showing the status of the COM port connection
    COMportHint = T.apply(Label(COMframe, width=17))
    COMportHint.grid(row=1, column=0, padx=5, pady=5)

    #refresh button
    T.apply(Button(COMframe, text='Rescan COM Ports', command=getCOMs)).grid(row=0, column=2, padx=5, pady=5)

    #connect Button
    connectCOMButton = T.apply(Button(COMframe, text='Connect', command=connectCOM))
    connectCOMButton.grid(row=0, column=1, padx=5, pady=5)

    #disconnect Button
    disconnectCOMButton = T.apply(Button(COMframe, text='Disconnect', command=disconnectCOM))
    disconnectCOMButton.grid(row=1, column=1, padx=5, pady=5)

    COMframe.pack(side=TOP, padx=5, pady=5)

    getCOMs() #scan ports to populate list for the first time

    #Create interactable elements for API server setup

    #Entry for inputing the desired net port
    APIportEntry = T(Entry(APIframe, width=25))
    APIportEntry.grid(row=0, column=0, padx=5, pady=5)

    #hint showing the status of the API connection
    APIhint = T(Label(APIframe, width=25))
    APIhint.grid(row=1, column=0, padx=5, pady=5)

    #connect button
    connectAPIButton = T(Button(APIframe, text='Connect', command=connectAPI))
    connectAPIButton.grid(row=0, column=1, padx=5, pady=5)

    #disconnect button
    disconnectAPIButton = T(Button(APIframe, text='Disconnect', command = disconnectAPI))
    disconnectAPIButton.grid(row=1, column=1, padx=5, pady=5)

    APIframe.pack(side=TOP, padx=5, pady=5)

    #close button
    T.apply(Button(tl, text='Close', command=tl.destroy)).pack(side=BOTTOM, padx=5, pady=5)

    #set min window size
    tl.update_idletasks()
    tl.minsize(width=max(tl.winfo_reqwidth(),0), height=max(tl.winfo_reqheight(),0))

#editTests, creates a new dialog for editting the information of each test
def editTests(initialTestNum=0):
    global tests
    if len(tests) == 0:
        messagebox.showerror("Power Tools Test Manager", "There are no tests to edit", parent=root.focus_get())
        return
    #setup the new menu
    editor = T.apply(Toplevel())
    editor.title("Edit Stations")
    editor.grab_set() #make window modal
    editor.focus_set()

    topFrame = T.apply(Frame(editor, bd=0))
    topFrame.pack(side=TOP)

    midFrame = T.apply(Frame(editor, bd=0))
    midFrame.pack(side=TOP)

    botFrame = T.apply(Frame(editor, bd=0))
    botFrame.pack(side=BOTTOM)

    #find the index associated with the given testNum, or resolve to a default value otherwise
    if initialTestNum in testIndexDict:
        currentTestIndex=testIndexDict[initialTestNum]
    else:
        currentTestIndex=-1

    #Draw empty fields, may want to disable in the future
    T.apply(Label(topFrame, text="PLC Slave Address: ")).grid(row=1, column=1)
    slaveAddressEntry = T.apply(Entry(topFrame))
    slaveAddressEntry.grid(row=1, column=2, pady=5, padx=10)
    
    T.apply(Label(topFrame, text="Station Title: ")).grid(row=2, column=1)
    nameEntry = T.apply(Entry(topFrame))
    nameEntry.grid(row=2, column=2, pady=5, padx=10)

    T.apply(Label(topFrame, text="Station Subtitle: ")).grid(row=3, column=1)
    serialEntry = T.apply(Entry(topFrame))
    serialEntry.grid(row=3, column=2, pady=5, padx=10)
    
    T.apply(Label(midFrame, text="Enter names and units for data types\n Select checkbox to display datatype on test manager:")).grid(row=2, column=0, columnspan=8)

    #Building an array of the interactable objects for expandable data
    numLabel = []
    valNameEntries = []
    unitEntries = []
    showEntry = []
    showEntryVar = []
    for ii in range(numberOfData):
        numLabel.append(T.apply(Label(midFrame, text=str(ii+1))))
        valNameEntries.append(T.apply(Entry(midFrame)))
        unitEntries.append(T.apply(Entry(midFrame, width=5)))
        showEntryVar.append(IntVar())
        showEntry.append(T.apply(Checkbutton(midFrame, variable=showEntryVar[ii], onvalue=1, offvalue=0)))

        numLabel[ii].grid(row=(ii%16+3), column=(int(ii/16)*4))
        valNameEntries[ii].grid(row=(ii%16+3), column=(int(ii/16)*4+1), padx=5)
        unitEntries[ii].grid(row=(ii%16+3), column=(int(ii/16)*4+2), padx=0)
        showEntry[ii].grid(row=(ii%16+3), column=(int(ii/16)*4+3))

    def save():
        tests[currentTestIndex].testNum = int(slaveAddressEntry.get()) 
        tests[currentTestIndex].name = nameEntry.get()
        tests[currentTestIndex].serial = serialEntry.get()
        for ii in range(numberOfData):
            tests[currentTestIndex].data[ii][0] = valNameEntries[ii].get()
            tests[currentTestIndex].data[ii][1] = unitEntries[ii].get()
            tests[currentTestIndex].data[ii][3] = bool(showEntryVar[ii].get())
        update()

    def apply():
        save()
        messagebox.showinfo("Power Tools Test Manager", "Changes Saved", parent=root.focus_get())

    def saveAndClose():
        save()
        editor.destroy()
    
    #select, fills fields with existing info when a test is selected 
    def select(testIndex):
        global tests
        nonlocal currentTestIndex
        currentTestIndex=testIndex
        if (currentTestIndex >= 0):
            dropdown.config(text=("Station "+str(tests[currentTestIndex].testNum)+": "+tests[testIndex].name+" \U000025BC"))

            slaveAddressEntry.config(state=NORMAL)
            slaveAddressEntry.delete(0, END)
            slaveAddressEntry.insert(0, tests[currentTestIndex].testNum)
            nameEntry.config(state=NORMAL)
            nameEntry.delete(0, END)
            nameEntry.insert(0, tests[currentTestIndex].name)
            serialEntry.config(state=NORMAL)
            serialEntry.delete(0, END)
            serialEntry.insert(0, tests[currentTestIndex].serial)
            
            for ii in range(numberOfData):
                valNameEntries[ii].config(state=NORMAL)
                valNameEntries[ii].delete(0, END)
                valNameEntries[ii].insert(0, tests[currentTestIndex].data[ii][0])
                unitEntries[ii].config(state=NORMAL)
                unitEntries[ii].delete(0, END)
                unitEntries[ii].insert(0, tests[currentTestIndex].data[ii][1])
                
                
                showEntry[ii].config(state=NORMAL)
                if tests[currentTestIndex].data[ii][3] == 1:
                    showEntry[ii].select()
                else:
                    showEntry[ii].deselect()

            saveButton.config(state=NORMAL)
            saveAndCloseButton.config(state=NORMAL)
            selectAllButton.config(state=NORMAL)
            deselectAllButton.config(state=NORMAL)
        else:
            dropdown.config(text=("Choose a station to edit \U000025BC"))
            
            slaveAddressEntry.delete(0, END)
            slaveAddressEntry.config(state=DISABLED)
            nameEntry.delete(0, END)
            nameEntry.config(state=DISABLED)
            serialEntry.delete(0, END)
            serialEntry.config(state=DISABLED)
            
            for ii in range(numberOfData):
                valNameEntries[ii].delete(0, END)
                valNameEntries[ii].config(state=DISABLED)
                unitEntries[ii].delete(0, END)
                unitEntries[ii].config(state=DISABLED)
                showEntry[ii].deselect()
                showEntry[ii].config(state=DISABLED)

            saveButton.config(state=DISABLED)
            saveAndCloseButton.config(state=DISABLED)
            selectAllButton.config(state=DISABLED)
            deselectAllButton.config(state=DISABLED)
            

    #quickly selects all data
    def selectAll():
        nonlocal showEntry
        for i in range(len(showEntry)):
            showEntry[i].select()
            
    #quickly deselects all data   
    def deselectAll():
        nonlocal showEntry
        for i in range(len(showEntry)):
            showEntry[i].deselect()

    #draw test chooser dropdown
    dropdown = T.apply(Menubutton(topFrame, text="[default]", relief=RAISED))
    dropdown.menu = T.apply(Menu(dropdown, tearoff=0))
    dropdown["menu"] = dropdown.menu
    for ii in range(len(tests)):
        dropdown.menu.add_command(label=("Station "+str(tests[ii].testNum)+": "+tests[ii].name), command=lambda x=ii: select(x))
    dropdown.grid(row=0, column=2, pady=5, padx=10)

    #save without closing button
    saveButton = T.apply(Button(botFrame, text="Apply Changes", command=apply))
    saveButton.grid(row=0, column=2, padx=5, pady=5)

    #save button
    saveAndCloseButton = T.apply(Button(botFrame, text="Save and Close", command=saveAndClose))
    saveAndCloseButton.grid(row=0, column=3, padx=5, pady=5)

    #cancel button
    T.apply(Button(botFrame, text="Close", command=editor.destroy)).grid(row=0, column=4, padx=5, pady=5)

    #Select All button
    selectAllButton = T.apply(Button(botFrame, text="Select All", command=selectAll))
    selectAllButton.grid(row=0, column=0, padx=5, pady=5)
    
    #Deselect All button
    deselectAllButton = T.apply(Button(botFrame, text="Deselect All", command=deselectAll))
    deselectAllButton.grid(row=0, column=1, padx=5, pady=5)

    select(currentTestIndex)

    #set min window size
    editor.update_idletasks()
    editor.minsize(width=max(editor.winfo_reqwidth(),300), height=max(editor.winfo_reqheight(),200))

#addTest(), adds a new test to the end of the list
def addTest():
    global tests
    global defaultValNames

    #setup the new menu
    adder = T.apply(Toplevel())
    adder.title("Add Station")
    adder.grab_set() #make window modal
    adder.focus_set()

    topFrame = T.apply(Frame(adder, bd=0))
    topFrame.pack(side=TOP)

    midFrame = T.apply(Frame(adder, bd=0))
    midFrame.pack(side=TOP)

    botFrame = T.apply(Frame(adder, bd=0))
    botFrame.pack(side=BOTTOM)

    #Draw empty fields
    T.apply(Label(topFrame, text="PLC Slave Address: ")).grid(row=0, column=0)
    slaveAddressEntry = T.apply(Entry(topFrame))
    slaveAddressEntry.grid(row=0, column=1, pady=5, padx=10)
    
    T.apply(Label(topFrame, text="Station Title: ")).grid(row=1, column=0)
    nameEntry = T.apply(Entry(topFrame))
    nameEntry.grid(row=1, column=1, pady=5, padx=10)

    T.apply(Label(topFrame, text="Station Subtitle: ")).grid(row=2, column=0)
    serialEntry = T.apply(Entry(topFrame))
    serialEntry.grid(row=2, column=1, pady=5, padx=10)

    T.apply(Label(topFrame, text="Enter names and units for data types.\n Select checkbox to display datatype on test manager:")).grid(row=3, column=0, columnspan=8)

    #Building an array of the interactable objects for expandable data
    numLabel = []
    valNameEntries = []
    unitEntries = []
    showEntry = []
    showEntryVar = []
    for ii in range(numberOfData):
        #populate lists
        numLabel.append(T.apply(Label(midFrame, text=str(ii+1))))
        valNameEntries.append(T.apply(Entry(midFrame)))
        unitEntries.append(T.apply(Entry(midFrame, width=5)))
        showEntryVar.append(IntVar())
        showEntry.append(T.apply(Checkbutton(midFrame, variable=showEntryVar[ii], onvalue=1, offvalue=0)))

        #populate entries with default values
        valNameEntries[ii].insert(0, defaultValNames[ii])
        
        #draw widgets to screen
        numLabel[ii].grid(row=(ii%16+3), column=(int(ii/16)*4))
        valNameEntries[ii].grid(row=(ii%16+3), column=(int(ii/16)*4+1), padx=5)
        unitEntries[ii].grid(row=(ii%16+3), column=(int(ii/16)*4+2), padx=0)
        showEntry[ii].grid(row=(ii%16+3), column=(int(ii/16)*4+3))

    #as a default, the first 2 fields will be selected
    showEntry[0].select()
    showEntry[1].select()

    #returns true if the station is added successfully, false otherwise
    def add():
        global tests
        global defaultValNames
        try:
            testNum = int(slaveAddressEntry.get()) #Slave PLC address

            #check for duplicate slave addresses and prompt the user if a duplicate is found
            if testNum>0 and testNum in [oo.testNum for oo in tests]:
                duplicateOk = messagebox.askyesno("Power Tools Test Manager", "That address is already in use.  Continue?", parent=root.focus_get())
            else:
                duplicateOk = True
                
            if duplicateOk:
                data = []
                for ii in range(numberOfData):
                    data.append([valNameEntries[ii].get(), unitEntries[ii].get(), 0, bool(showEntryVar[ii].get())])
                    
                tests.append(Test(slaveAddressEntry.get(), nameEntry.get(), serialEntry.get(), data))
                update()
                return True
            else:    
                return False
            
        except ValueError as e:
            messagebox.showerror("Power Tools Test Manager", "Invalid Address", parent=root.focus_get())
            return False

    def addDontExit():
        if add():
            messagebox.showinfo("Power Tools Test Manager", "Test Added", parent=root.focus_get())

    def addAndExit():
        if add():
            adder.destroy()

    #quickly selects all tests
    def selectAll():
        nonlocal showEntry
        for i in range(len(showEntry)):
            showEntry[i].select()
    #quickly deselects all tests   
    def deselectAll():
        nonlocal showEntry
        for i in range(len(showEntry)):
            showEntry[i].deselect()
    
    #save button
    T.apply(Button(botFrame, text="Add Station", command = addDontExit)).grid(row=0, column=2, padx=5, pady=5)
    #save button
    T.apply(Button(botFrame, text="Add and Close", command = addAndExit)).grid(row=0, column=3, padx=5, pady=5)
    #cancel button
    T.apply(Button(botFrame, text="Close", command=adder.destroy)).grid(row=0, column=4, padx=5, pady=5)
    #Select All button
    T.apply(Button(botFrame, text="Select All", command=selectAll)).grid(row=0, column=0, padx=5, pady=5)
    #Deselect All button
    T.apply(Button(botFrame, text="Deselect All", command=deselectAll)).grid(row=0, column=1, padx=5, pady=5)

    #set min window size
    adder.update_idletasks()
    adder.minsize(width=max(adder.winfo_reqwidth(),300), height=max(adder.winfo_reqheight(),200))

#deleteTest(), deletes a test after being selected from a drop-down menu
def deleteTest():
    global tests

    if len(tests) == 0:
        messagebox.showerror("Power Tools Test Manager", "There are no tests to delete", parent=root.focus_get())
        return
    
    #setup the new menu
    deleter = T.apply(Toplevel())
    deleter.title("Delete Stations")
    deleter.grab_set() #make window modal
    deleter.focus_set()

    optionsFrame = T.apply(Frame(deleter, bd=0))
    optionsFrame.pack(side=TOP)

    botFrame = T.apply(Frame(deleter, bd=0))
    botFrame.pack(side=BOTTOM)
    
    #list of all labels
    l = []
    #response list of IntVar()
    r = []
    #list of all checkbuttons
    c = []
    #draw the set of checkboxes to the screen
    for i in range(len(tests)):
        option = "Station "+str(tests[i].testNum)+": "+tests[i].name
        l.append(SelectLabel(optionsFrame, text=option, bg=T.theme.bg, fg=T.theme.fg, selectbackground=T.theme.selectbg, selectforeground=T.theme.selectfg, font=(T.family, T.size)))
        r.append(IntVar())
        r[i].set(0)
        c.append(T.apply(Checkbutton(optionsFrame, text=None, variable=r[i], onvalue=1, offvalue=0, padx=10)))

        l[-1].grid(row=i%10, column=(i//10)*2)
        c[i].grid(row=i%10, column=(i//10)*2+1)

    def delete():
        for ii in range(len(r)-1,-1,-1):
            if bool(r[ii].get()):
                del tests[ii]
        update()
        deleter.destroy()

    #quickly selects all tests
    def selectAll():
        nonlocal c
        for i in range(len(c)):
            c[i].select()

    #quickly deselects all tests   
    def deselectAll():
        nonlocal c
        for i in range(len(c)):
            c[i].deselect()

    #save button
    T.apply(Button(botFrame, text="Delete Stations", command = delete)).grid(row=1, column=2, padx=5, pady=5)
    #cancel button
    T.apply(Button(botFrame, text="Cancel", command=deleter.destroy)).grid(row=1, column=3, padx=5, pady=5)
    #Select All button
    T.apply(Button(botFrame, text="Select All", command=selectAll)).grid(row=1, column=0, padx=5, pady=5)
    #Deselect All button
    T.apply(Button(botFrame, text="Deselect All", command=deselectAll)).grid(row=1, column=1, padx=5, pady=5)

    deleter.update_idletasks()
    deleter.minsize(width=max(deleter.winfo_reqwidth(),300), height=max(deleter.winfo_reqheight(),200))

#changeView, opens a dialog which allows the user to choose which tests are drawn on the screen    
def changeView():
    global tests

    if len(tests) == 0:
        messagebox.showerror("Power Tools Test Manager", "There are no stations to show", parent=root.focus_get())
        return
    
    #setup the new menu
    view = T.apply(Toplevel())
    view.title("Hide/Show Stations")
    view.grab_set() #make window modal
    view.focus_set()

    T.apply(Label(view, text="Deselected stations will be hidden")).pack(side=TOP)

    topFrame = T.apply(LabelFrame(view, bd=0))
    topFrame.pack(side=TOP)

    botFrame = T.apply(LabelFrame(view, bd=0))
    botFrame.pack(side=BOTTOM)

    #dictionary linking option name to internal index
    l = []
    #response list of IntVar()
    r = []
    #list of all checkbuttons
    c = []
    #draw the set of checkboxes to the screen
    for i in range(len(tests)):
        option = "Test "+str(tests[i].testNum)+": "+tests[i].name
        l.append(SelectLabel(topFrame, text=option, bg=T.theme.bg, fg=T.theme.fg, selectbackground=T.theme.selectbg, selectforeground=T.theme.selectfg, font=(T.family, T.size)))
        r.append(IntVar())
        r[i].set(tests[i].showTest)
        c.append(T.apply(Checkbutton(topFrame, text=None, variable=r[i], onvalue=1, offvalue=0, padx=10)))

        l[-1].grid(row=i%10, column=(i//10)*2)
        c[-1].grid(row=i%10, column=(i//10)*2+1)
        
        if r[i].get() == 1:
            c[i].select()
        
    #save changes made during the dialog
    def save():
        for i in range(len(r)):
            tests[i].showTest=int(r[i].get())
        update()
        view.destroy()
        
    #quickly selects all tests
    def selectAll():
        nonlocal c
        for i in range(len(c)):
            c[i].select()
    #quickly deselects all tests   
    def deselectAll():
        nonlocal c
        for i in range(len(c)):
            c[i].deselect()
            
    #cancel button
    T.apply(Button(botFrame, text="Cancel", command=view.destroy)).grid(row=0, column=3, padx=5, pady=5)
    #save button
    T.apply(Button(botFrame, text="Save", command=save)).grid(row=0, column=2, padx=5, pady=5)
    #Select All button
    T.apply(Button(botFrame, text="Select All", command=selectAll)).grid(row=0, column=0, padx=5, pady=5)
    #Deselect All button
    T.apply(Button(botFrame, text="Deselect All", command=deselectAll)).grid(row=0, column=1, padx=5, pady=5)

    view.update_idletasks()
    view.minsize(width=max(view.winfo_reqwidth(),300), height=max(view.winfo_reqheight(),200))

#writeToFile, allows the user to store current test information in a .txt file of their choice
def writeToFile():
    global tests
    #setup the new menu
    writer = T.apply(Toplevel())
    writer.title("Write To File")
    writer.grab_set() #make window modal
    writer.focus_set()

    T.apply(Label(writer, text="Selected stations will appear on the file")).pack(side=TOP)

    topFrame = T.apply(LabelFrame(writer, bd=0))
    topFrame.pack(side=TOP)

    botFrame = T.apply(LabelFrame(writer, bd=0))
    botFrame.pack(side=BOTTOM)
    
    #dictionary linking option name to internal index
    l = []
    #response list of IntVar()
    r = []
    #list of all checkbuttons
    c = []
    #draw the set of checkboxes to the screen
    for i in range(len(tests)):
        option = "Station "+str(tests[i].testNum)+": "+tests[i].name
        l.append(SelectLabel(topFrame, text=option, bg=T.theme.bg, fg=T.theme.fg, selectbackground=T.theme.selectbg, selectforeground=T.theme.selectfg, font=(T.family, T.size)))
        r.append(IntVar())
        r[i].set(tests[i].showTest)
        c.append(T.apply(Checkbutton(topFrame, text=None, variable=r[i], onvalue=1, offvalue=0, padx=10)))

        l[-1].grid(row=i%10, column=(i//10)*2)
        c[-1].grid(row=i%10, column=(i//10)*2+1)
        
        if r[i].get() == 1:
            c[i].select()

    ctVar = BooleanVar()
    commentToggle = T.apply(Checkbutton(writer, text = "Include Comments?", variable = ctVar, onvalue=1, offvalue=0, padx=0))
    commentToggle.pack(side=BOTTOM)
    commentToggle.select()
        
    #writes specified info to file
    def save():
        try:
            #open *.txt file using system dialog
            file = filedialog.asksaveasfile(parent=writer, initialdir = "/", title = "Save As", filetypes = (("Text Files","*.txt"),), defaultextension="*.*")
        except OSError as e: #catch errors relating to opening the file
            messagebox.showerror("Power Tools Test Manager", "Could not open file", parent=root.focus_get())
        else:
            if not file is None:
                file.write("Snap-On Test Manager, Version "+version+"\n")
                file.write(datetime.now().strftime("Data Captured on %m/%d/%Y at %H:%M:%S"))
                for i in range(len(r)):
                    if r[i].get() == 1:
                        if ctVar.get():
                            file.write("\n\nStation "+str(tests[i].testNum)+": "+str(tests[i].toStringPlusComments()))
                        else:
                            file.write("\n\nStation "+str(tests[i].testNum)+": "+str(tests[i].toString()))
                writer.destroy()
        finally:
            if not file is None:
                file.close()
        
    #quickly selects all tests
    def selectAll():
        nonlocal c
        for i in range(len(c)):
            c[i].select()
            
    #quickly deselects all tests   
    def deselectAll():
        nonlocal c
        for i in range(len(c)):
            c[i].deselect()
            
    #cancel button
    T.apply(Button(botFrame, text="Cancel", command=writer.destroy)).grid(row=2, column=3, padx=5, pady=5)
    #save button
    T.apply(Button(botFrame, text="Save As", command=save)).grid(row=2, column=2, padx=5, pady=5)
    #Select All button
    T.apply(Button(botFrame, text="Select All", command=selectAll)).grid(row=2, column=0, padx=5, pady=5)
    #Deselect All button
    T.apply(Button(botFrame, text="Deselect All", command=deselectAll)).grid(row=2, column=1, padx=5, pady=5)

    #set window minimum size
    writer.update_idletasks()
    writer.minsize(width=max(writer.winfo_reqwidth(),300), height=max(writer.winfo_reqheight(),200))


#lockDisplay, will make most functions and buttons unusable
#not protected by password
def lockDisplay():
    global locked
    global passlocked
    global password
    locked = True
    passlocked = False
    update()

#lockDisplayWithPass, will make most functions and buttons unusable
#prompts the user to submit a password
def lockDisplayWithPass():
    global locked
    global passlocked
    global password
    #setup the new menu
    locker = T.apply(Toplevel())
    locker.title("Lock Display")
    locker.grab_set() #make window modal
    locker.focus_set()
    
    passEntry = T.apply(Entry(locker))
    passEntry.grid(row=0, column=1, padx=5, pady=5)
    
    def lockWithPass():
        global locked
        global passlocked
        global password
        locked = True
        passlocked = True
        password = passEntry.get()
        update()
        locker.destroy()
        
    #deprecated
    def lockWithoutPass():
        global locked
        global passlocked
        global password
        locked = True
        passlocked = True
        update()
        locker.destroy()
        
    def cancel():
        locker.destroy()

    #drawing locker controls
    T.apply(Label(locker, text="Enter Password:")).grid(row=0, column=0, padx=5, pady=5)   
    T.apply(Button(locker, text = "Lock", command=lockWithPass)).grid(row=1, column=0, padx=5, pady=5)
    T.apply(Button(locker, text = "Cancel", command=cancel)).grid(row=1, column=1, padx=5, pady=5)

    #set window minimum size
    locker.update_idletasks()
    locker.minsize(width=max(locker.winfo_reqwidth(),0), height=max(locker.winfo_reqheight(),0))

    
#unlock display, either unlocks the display if it isn't password protected,
#or prompts for a password
def unlockDisplay():
    global locked
    global passlocked
    global password
    if not passlocked:
        locked = False
        update()
    else:
        #setup the new menu
        unlocker = T.apply(Toplevel(padx=10))
        unlocker.title("Unlock Display")
        unlocker.grab_set() #make window modal
        unlocker.focus_set()
        
        passEntry = T.apply(Entry(unlocker, show="*"))
        passEntry.grid(row=0, column=1, padx=5, pady=5)

        def unlock():
            global locked
            global passlocked
            global password
            if passEntry.get() == password:
                locked = False
                passlocked = False
                password = ""
                update()
                unlocker.destroy()
            else:
                messagebox.showerror("Power Tools Test Manager", "Incorrect password", parent=root.focus_get())
            
        def cancel():
            unlocker.destroy()
            return

        #draw unlocker controls
        T.apply(Label(unlocker, text="Enter Password:")).grid(row=0, column=0, padx=5, pady=5)   
        T.apply(Button(unlocker, text = "Unlock", command=unlock)).grid(row=1, column=0, padx=5, pady=5)
        T.apply(Button(unlocker, text = "Cancel", command=cancel)).grid(row=1, column=1, padx=5, pady=5)

        #set window minimum size
        unlocker.update_idletasks()
        unlocker.minsize(width=max(unlocker.winfo_reqwidth(),0), height=max(unlocker.winfo_reqheight(),0))

#addComment, opens a new dialog which will allow the user to write and save comments for each test
def addComment():
    global tests
    
    if len(tests) == 0:
        messagebox.showerror("Power Tools Test Manager", "There are no tests to add a comment to", parent=root.focus_get())
        return
    
    #setup the new menu
    commenter = T.apply(Toplevel())
    commenter.title("Add a Comment")
    commenter.grab_set() #make window modal
    commenter.focus_set()
    
    #dictionary linking option name to internal index
    l = {}
    for i in range(len(tests)):
        l["Test "+str(tests[i].testNum)+": "+tests[i].name] = i
    
    #draw test chooser dropdown
    r=StringVar()
    r.set("Choose a station to add a comment")
    OptionMenu(commenter, r, *l.keys(), command=lambda r: saveButton.config(state=NORMAL)).grid(row=0, column=0, columnspan=2)
    
    commentEntry = Text(commenter, height=15, width=50)
    commentEntry.grid(row=1, column=0, columnspan=2)

    #adds the comment as a tuple to the test object, and closes the window
    def add():
        nonlocal commentEntry
        tests[l[r.get()]].addComment(commentEntry.get('1.0', 'end-1c'))
        commenter.destroy()
                                    
    #save button
    saveButton = Button(commenter, text="Add Comment", command=add, state=DISABLED)
    saveButton.grid(row=5, pady=5)
    #cancel button
    Button(commenter, text="Cancel", command=commenter.destroy).grid(row=5, column=1)

    #set min window size
    commenter.update_idletasks()
    commenter.minsize(width=max(commenter.winfo_reqwidth(),0), height=max(commenter.winfo_reqheight(),0))

#viewComments, opens a new dialog that allows the user to view the comments on a test, or all of the comments from all tests simultaneously  
def viewComments():
    global tests
    global allComments

    if len(tests) == 0:
        messagebox.showerror("Power Tools Test Manager", "There are no stations to view", parent=root.focus_get())
        return
    
    #setup the new menu
    commentViewer = T.apply(Toplevel())
    commentViewer.title("View Comments")
    commentViewer.grab_set() #make window modal
    commentViewer.focus_set()
    
    #dictionary linking option name to internal index
    l = {}
    l["View All"] = -1
    for i in range(len(tests)):
        l["Station "+str(tests[i].testNum)+": "+tests[i].name] = i

    commentLabel = Label(commentViewer, justify=LEFT, anchor = W)
    commentLabel.grid(row=1, column=0, columnspan=2, padx=10, pady=3)

    #draws the comments to the screen
    def displayComments(r):
        nonlocal commentLabel
        if r == "View All":
            string = Test.getAllComments()
        else:
            string = tests[l[r]].getComments()
        if string == "":
            string = "No Comments"
        commentLabel.config(text=string)

    #draw test chooser dropdown
    r=StringVar()
    r.set("View All")
    OptionMenu(commentViewer, r, *l.keys(), command=displayComments).grid(row=0, padx=10, pady=2)
    #draws comments to the screen for the first time
    displayComments(r.get())

    Button(commentViewer, text='Exit', command=commentViewer.destroy).grid(row=0, column=1, padx=5)

    #set min window size
    commentViewer.update_idletasks()
    commentViewer.minsize(width=max(commentViewer.winfo_reqwidth(),260), height=max(commentViewer.winfo_reqheight(),60))
    
#editControls():  presents the user with a window where they can assign labels to the PLC's control coils for each station.
#if given a valid TestNum from an existing station, the window will start with that station selected
def editControls(initialTestNum=0):
    global tests
    if len(tests) == 0:
        messagebox.showerror("Power Tools Test Manager", "There are no stations to edit", parent=root.focus_get())
        return
    #setup the new menu
    editor = T.apply(Toplevel())
    editor.title("Label Controls")
    editor.grab_set() #make window modal
    editor.focus_set()

    topFrame = T.apply(Frame(editor, bd=0))
    topFrame.pack(side=TOP)

    midFrame = T.apply(Frame(editor, bd=0))
    midFrame.pack(side=TOP)

    botFrame = T.apply(Frame(editor, bd=0))
    botFrame.pack(side=BOTTOM)

    if initialTestNum in testIndexDict:
        currentTestIndex=testIndexDict[initialTestNum]
    else:
        currentTestIndex=-1
    
    T.apply(Label(midFrame, text="Enter labels for control buttons")).grid(row=2, column=0, columnspan=8)

    #Building an array of the interactable objects
    numLabel = []
    controlNameEntries = []
    for ii in range(numberOfControls):
        numLabel.append(T.apply(Label(midFrame, text=str(ii+1))))
        controlNameEntries.append(T.apply(Entry(midFrame)))

        numLabel[ii].grid(row=(ii%16+3), column=(int(ii/16)*4))
        controlNameEntries[ii].grid(row=(ii%16+3), column=(int(ii/16)*4+1), padx=5)


    def save():
        for ii in range(numberOfControls):
            tests[currentTestIndex].controls[ii][0] = controlNameEntries[ii].get()
        #update()

    def apply():
        save()
        messagebox.showinfo("Power Tools Test Manager", "Changes Saved", parent=root.focus_get())
        
    def saveAndClose():
        save()
        editor.destroy()

    
    #select, fills fields with existing info when a test is selected.  If a negative index is passed, the window will be populated with a default selection
    def select(testIndex):
        global tests
        nonlocal currentTestIndex
        currentTestIndex=testIndex
        if (currentTestIndex >= 0):
            dropdown.config(text=("Station "+str(tests[testIndex].testNum)+": "+tests[testIndex].name+" \U000025BC"))
            saveButton.config(state=NORMAL, command=save)
            saveAndCloseButton.config(state=NORMAL)

            for ii in range(numberOfControls):
                controlNameEntries[ii].config(state=NORMAL)
                controlNameEntries[ii].delete(0, END)
                controlNameEntries[ii].insert(0, tests[currentTestIndex].controls[ii][0])
        else:
            dropdown.config(text=("Choose a station to edit \U000025BC"))
            for ii in range(numberOfControls):
                controlNameEntries[ii].delete(0, END)
                controlNameEntries[ii].config(state=DISABLED)

            saveButton.config(state=DISABLED)
            saveAndCloseButton.config(state=DISABLED)

    #draw test chooser dropdown
    dropdown = T.apply(Menubutton(topFrame, text="[default]", relief=RAISED))
    dropdown.menu = T.apply(Menu(dropdown, tearoff=0))
    dropdown["menu"] = dropdown.menu
    for ii in range(len(tests)):
        dropdown.menu.add_command(label=("Station "+str(tests[ii].testNum)+": "+tests[ii].name), command=lambda x=ii: select(x))
    dropdown.grid()
    
    #save button
    saveButton = T.apply(Button(botFrame, text="Apply Changes", command=apply))
    saveButton.grid(row=0, column=2, padx=5, pady=5)

    #save and close button
    saveAndCloseButton = T.apply(Button(botFrame, text="Save and Close", command=saveAndClose))
    saveAndCloseButton.grid(row=0, column=3, padx=5, pady=5)

    #cancel button
    T.apply(Button(botFrame, text="Cancel", command=editor.destroy)).grid(row=0, column=4, padx=5, pady=5)

    #populate fields for the first time
    select(currentTestIndex)

    #set min window size
    editor.update_idletasks()
    editor.minsize(width=max(editor.winfo_reqwidth(),300), height=max(editor.winfo_reqheight(),200))

#openControls(): This function opens a new child window which will allow the user to see the status of the selected station's
#control coils, and toggle them on or off
#if given a valid TestNum from an existing station, the window will start with that station selected
def openControls(InitialTestNum=0):
    global tests
    global testIndexDict
    if len(tests) == 0:
        messagebox.showerror("Power Tools Test Manager", "There are no stations to control", parent=root.focus_get())
        return
    if not poll.is_open():
        messagebox.showerror("Power Tools Test Manager", "Not connected to a serial port", parent=root.focus_get())
        return
    #setup the new menu
    tl = T.apply(Toplevel())
    tl.title("Station Controls")
    tl.grab_set() #make window modal
    tl.focus_set()

    topFrame = T.apply(Frame(tl, bd=0))
    topFrame.pack(side=TOP)

    midFrame = T.apply(Frame(tl, bd=0))
    midFrame.pack(side=TOP)

    botFrame = T.apply(Frame(tl, bd=0))
    botFrame.pack(side=BOTTOM)

    if InitialTestNum in testIndexDict:
        currentTestIndex=testIndexDict[InitialTestNum]
    else:
        currentTestIndex=-1

    #Building an array of the interactable objects
    numLabel = []
    controlButtons = []
    controlNameLabels = []
    for ii in range(numberOfControls):
        numLabel.append(T.apply(Label(midFrame, text=str(ii+1))))
        controlButtons.append(T.apply(Button(midFrame, width=8)))
        controlNameLabels.append(Label(midFrame, width=10, bg=T.theme.contrast_bg, fg=T.theme.contrast_fg, font=(T.family, T.size), justify=LEFT))

        numLabel[ii].grid(row=(ii%16+3), column=(int(ii/16)*4))
        controlButtons[ii].grid(row=(ii%16+3), column=(int(ii/16)*4+1))
        controlNameLabels[ii].grid(row=(ii%16+3), column=(int(ii/16)*4+2), padx=5)

    
    def sendCommand(controlIndex, value):
        poll.control(tests[currentTestIndex], controlIndex, value)
        update(currentTestIndex)


    dropdown = T.apply(Menubutton(topFrame, text="[default]", relief=RAISED))

    #update() is called whenever a new selection is made on the dropdown menu.  It reconfigures the window to reflect what was chosen.
    #if update() is passed an invalid index, then it will show a default selection
    def update(testIndex): #TODO: test
        nonlocal currentTestIndex
        currentTestIndex=testIndex
        if (currentTestIndex>=0): 
            dropdown.config(text=("Station "+str(tests[testIndex].testNum)+": "+tests[testIndex].name+" \U000025BC"))

            poll.retrieveControls(tests[currentTestIndex])

            for ii in range(numberOfControls):
                controlNameLabels[ii].config(text=tests[currentTestIndex].controls[ii][0])
                if tests[currentTestIndex].status == Test.OFFLINE:
                    controlButtons[ii].config(text="OFFLINE", fg=T.theme.fg, state=DISABLED, command=None)
                else:
                    if tests[currentTestIndex].controls[ii][1]:
                        controlButtons[ii].config(text="ON", fg="green", state=NORMAL, command=lambda x=ii: sendCommand(x+1, 0))
                    else:
                        controlButtons[ii].config(text="OFF", fg=T.theme.fg, state=NORMAL, command=lambda x=ii: sendCommand(x+1, 1))                
                        
        else:
            dropdown.config(text=("Choose a station to control \U000025BC"))
            for ii in range(numberOfControls):
                controlNameLabels[ii].config(text="")
                controlButtons[ii].config(text="", state=DISABLED)

    #close the current window and open the control label editor for the selected test
    def openControlEditor():
        tl.destroy()
        if currentTestIndex>=0:
            editControls(tests[currentTestIndex].testNum)
        else:
            editControls()
        
    #create and assign a menu to the dropdown menubutton.  This menu will allow the user to select which station they want to control.
    dropdown.menu = T.apply(Menu(dropdown, tearoff=0))
    dropdown["menu"] = dropdown.menu
    for ii in range(len(tests)):
        dropdown.menu.add_command(label=("Station "+str(tests[ii].testNum)+": "+tests[ii].name), command=lambda x=ii: update(x))
    dropdown.grid()

    update(currentTestIndex) #populate the screen for the first time

    T.apply(Button(botFrame, text="Edit Labels", command=openControlEditor)).grid(row=0, column=0, padx=5, pady=5)

    #refresh button
    T.apply(Button(botFrame, text="Refresh", command=lambda: update(currentTestIndex))).grid(row=0, column=1, padx=5, pady=5)

    #cancel button
    T.apply(Button(botFrame, text="Close", command=tl.destroy)).grid(row=0, column=3, padx=5, pady=5)
    
    #set min window size
    tl.update_idletasks()
    tl.minsize(width=max(tl.winfo_reqwidth(),300), height=max(tl.winfo_reqheight(),200))

#pauseTests, gives the user a focused dialog for controlling the action of all connected stations
def pauseTests():
    global tests
    global testIndexDict
    if len(tests) == 0:
        messagebox.showerror("Power Tools Test Manager", "There are no stations to control", parent=root.focus_get())
        return
    if not poll.is_open():
        messagebox.showerror("Power Tools Test Manager", "Not connected to a serial port", parent=root.focus_get())
        return
    #setup the new menu
    tl = T.apply(Toplevel())
    tl.title("Pause/Resume Tests")
    tl.grab_set() #make window modal
    tl.focus_set()

    #window organization
    topFrame = T.apply(Frame(tl, bd=0))
    topFrame.pack(side=TOP)

    midFrame = T.apply(Frame(tl, bd=0))
    midFrame.pack(side=TOP)

    botFrame = T.apply(Frame(tl, bd=0))
    botFrame.pack(side=BOTTOM)

    #Set up main interactable elements.  This time, I used an enhanced for loop to try a more pythonic approach
    stationLabels = []
    pauseButtons = []
    for oo in tests:
        stationLabels.append(SelectLabel(midFrame, text="Station "+str(oo.testNum)+": "+oo.name, bg=T.theme.bg, fg=T.theme.fg, selectbackground=T.theme.selectbg, selectforeground=T.theme.selectfg, font=(T.family, T.size)))
        pauseButtons.append(T.apply(Button(midFrame, width=10)))

        stationLabels[-1].grid(column=(testIndexDict[oo.testNum]%10)*2, row=(testIndexDict[oo.testNum]//10)*2, padx=2, pady=3)
        pauseButtons[-1].grid(column=(testIndexDict[oo.testNum]%10)*2, row=(testIndexDict[oo.testNum]//10)*2+1, padx=2, pady=3)

    #with refresh is sort of like a decorator.  It takes a function f, and returns a new function w that executes f, and also refreshes this window.  
    #used during function assignment of UI controls
    def withRefresh(f):
        def w():
            f()
            refresh()
        return w

    #queries all test stations for their pause status and update controls to reflect
    def refresh():
        for oo in tests: #TODO fix
            poll.retrieveStatus(oo)

            if oo.status == Test.NORMAL:
                pauseButtons[testIndexDict[oo.testNum]].config(text=Test.NORMAL, fg="green", state=NORMAL, command=lambda: withRefresh(lambda x=oo: poll.pause(x.testNum))())
            elif oo.status == Test.PAUSED:
                pauseButtons[testIndexDict[oo.testNum]].config(text=Test.PAUSED, fg=T.theme.fg, state=NORMAL, command=lambda: withRefresh(lambda x=oo: poll.resume(x.testNum))())
            elif oo.status == Test.STOPPED:
                pauseButtons[testIndexDict[oo.testNum]].config(text=Test.STOPPED.upper(), fg="orange", state=DISABLED, command=None)
            elif oo.status == Test.OFFLINE:    
                pauseButtons[testIndexDict[oo.testNum]].config(text=Test.OFFLINE.upper(), fg="red", state=DISABLED, command=None)

    #populate the screen with current information for the first time
    refresh()

    #Pause all button
    T.apply(Button(botFrame, text="Pause All Tests", command=lambda: withRefresh(pauseAll)())).grid(row=0, column=0, padx=5, pady=5)

    #Resume all button
    T.apply(Button(botFrame, text="Resume All Tests", command=lambda: withRefresh(sendResumeAll)())).grid(row=0, column=1, padx=5, pady=5)

    #refresh button
    T.apply(Button(botFrame, text="Refresh", command=refresh)).grid(row=0, column=2, padx=5, pady=5)

    #cancel button
    T.apply(Button(botFrame, text="Close", command=tl.destroy)).grid(row=0, column=3, padx=5, pady=5)

    #set min window size
    tl.update_idletasks()
    tl.minsize(width=max(tl.winfo_reqwidth(),300), height=max(tl.winfo_reqheight(),200))


#theme():  This function opens a window that will allow the user to select which colors, font, and text size the program uses
#As new selections are made, this window will be updated to give the user a preview of the theme they have selected
def theme():
    global T
    #initialize a new ThemeAndFont() object based on the current global Theme
    newTheme=copy.deepcopy(T)

    #setup the new menu
    tl = newTheme.apply(Toplevel())
    tl.title("Configure Appearance")
    tl.grab_set() #make window modal
    tl.focus_set()

    topFrame = newTheme.apply(Frame(tl, bd=0))
    topFrame.pack(side=TOP)

    midFrame = newTheme.apply(Frame(tl, bd=0))
    midFrame.pack(side=TOP)

    botFrame = newTheme.apply(Frame(tl, bd=0))
    botFrame.pack(side=BOTTOM)

    terse = SelectLabel(topFrame, text="Current Theme: %s, %i %s" % (newTheme.theme.title, newTheme.size, newTheme.family), bg=newTheme.theme.bg, fg=newTheme.theme.fg, selectbackground=newTheme.theme.selectbg, selectforeground=newTheme.theme.selectfg, font=(newTheme.family, newTheme.size))
    terse.pack()

    def refresh():
        newTheme.set(theme=next((oo for oo in themes if oo.title == colorsVar.get()), tkTheme.Theme()), family=fontVar.get(), size=fontSizeVar.get())

        newTheme.apply([tl, topFrame, midFrame, botFrame])
        terse.config(text="Current Theme: %s, %i %s" % (newTheme.theme.title, newTheme.size, newTheme.family), bg=newTheme.theme.bg, fg=newTheme.theme.fg, selectbackground=newTheme.theme.selectbg, selectforeground=newTheme.theme.selectfg, font=(newTheme.family, newTheme.size))
        newTheme.apply([saveButton, cancelButton, r])
        for oo in [colorsHeader, fontSizeHeader, fontHeader]:
            oo.config(bg=newTheme.theme.bg, fg=newTheme.theme.fg, selectbackground=newTheme.theme.selectbg, selectforeground=newTheme.theme.selectfg, font=(newTheme.family, newTheme.size))
        for oo in l:
            oo.config(bg=newTheme.theme.bg, fg=newTheme.theme.fg, selectbackground=newTheme.theme.selectbg, selectforeground=newTheme.theme.selectfg, font=(newTheme.family, newTheme.size))

    r = [] #list of all radiobuttons
    l = [] #list of all accompanying labels

    colorsVar = StringVar(value=newTheme.theme.title)
    colorsOptions = [oo.title for oo in themes]
    colorsHeader = SelectLabel(midFrame, text="Color Theme:")
    colorsHeader.grid(row=0, column=1, columnspan=1)

    for ii in range(len(colorsOptions)):
        r.append(Radiobutton(midFrame, variable=colorsVar, value=colorsOptions[ii], command=refresh))
        l.append(SelectLabel(midFrame, text=colorsOptions[ii]))

        r[-1].grid(row=ii+1, column=0)
        l[-1].grid(row=ii+1, column=1)

    fontSizeVar = IntVar(value=newTheme.size)
    fontSizeHeader = SelectLabel(midFrame, text="Text Size:")
    fontSizeHeader.grid(row=0, column=5, columnspan=1)

    for ii in range(len(sizes)):
        r.append(Radiobutton(midFrame, variable=fontSizeVar, value=sizes[ii], command=refresh))
        l.append(SelectLabel(midFrame, text=str(sizes[ii])))

        r[-1].grid(row=ii+1, column=4)
        l[-1].grid(row=ii+1, column=5)

    fontVar = StringVar(value=newTheme.family)
    fontHeader = SelectLabel(midFrame, text="Font Family:")
    fontHeader.grid(row=0, column=3, columnspan=1)

    for ii in range(len(families)):
        r.append(Radiobutton(midFrame, variable=fontVar, value=families[ii], command=refresh))
        l.append(SelectLabel(midFrame, text=families[ii]))

        r[-1].grid(row=ii+1, column=2)
        l[-1].grid(row=ii+1, column=3)

    def save():
        global T
        T = newTheme
        update()
        tl.destroy()

    #save button
    saveButton = newTheme(Button(botFrame, text="Save", command=save))
    saveButton.grid(row=0, column=0, padx=5, pady=5)

    #cancel button
    cancelButton = newTheme(Button(botFrame, text="Cancel", command=tl.destroy))
    cancelButton.grid(row=0, column=3, padx=5, pady=5)

    #update the menu for the first time
    refresh()

    #set min window size
    tl.update_idletasks()
    tl.minsize(width=max(tl.winfo_reqwidth(),300), height=max(tl.winfo_reqheight(),200))

#build window, called at the beginning of program execution to populate the root window's basic structure
def buildWindow():
    #declaring dataFrame, which will hold all test widgets
    global dataFrame
    dataFrame = LabelFrame(root, bd=0)
    dataFrame.pack(side=TOP)

    #Version label in the far right, on a window-spanning relief bar
    global ver, verText
    ver = Frame(root, bd=1, relief=SUNKEN)
    verText = Label(ver, text="version " + version)
    verText.pack(side=RIGHT)
    ver.pack(side=BOTTOM, fill='x')

    #small control panel located at the bottom-center of the window
    global botControl
    botControl = Frame(root, bd=0)
    botControl.pack(side=BOTTOM, pady=2)

    #Create two buttons, located at the bottom of the screen, that can control the status of all stations at once
    global pauseAllButton, resumeAllButton
    pauseAllButton = Button(botControl, text="Pause All Tests", command=lambda poll=poll: poll.pauseAll())
    pauseAllButton.grid(row=0, column=0)
    resumeAllButton = Button(botControl, text="Resume All Tests", command=lambda poll=poll: poll.resumeAll())
    resumeAllButton.grid(row=0, column=1)

    #build the windows-style menubar with multiple cascades #TODO: weird line?? Fonts not working on menubar??? NOTE: this is probably unfixable
    global menubar, fileMenu, functionsMenu, viewMenu, lockSubMenu, controlsMenu
    menubar = Menu(root)

    fileMenu = Menu(menubar, tearoff=0)
    fileMenu.add_command(label="Save Session", command=saveSession)
    fileMenu.add_command(label="Open Session", command=openSession)
    fileMenu.add_command(label="Connections", command=connect)
    fileMenu.add_command(label="Write to File", command=writeToFile)
    fileMenu.add_command(label="Exit", command=exitProgram)
    menubar.add_cascade(label="File", menu=fileMenu)

    functionsMenu = Menu(menubar, tearoff=0)
    functionsMenu.add_command(label="Edit Stations", command=editTests)
    functionsMenu.add_command(label="Add Station", command=addTest)
    functionsMenu.add_command(label="Delete Station", command=deleteTest)
    functionsMenu.add_command(label="Label Controls", command=editControls)
    menubar.add_cascade(label="Edit", menu=functionsMenu)

    viewMenu = Menu(menubar, tearoff=0)
    viewMenu.add_command(label="Hide/Show Stations", command=changeView)
    viewMenu.add_command(label="Theme", command=theme)

    lockSubMenu = Menu(viewMenu, tearoff=0)
    lockSubMenu.add_command(label="Password Lock", command=lockDisplayWithPass)
    lockSubMenu.add_command(label="No Password Lock", command=lockDisplay)
    viewMenu.add_cascade(label="Lock Display", menu=lockSubMenu)

    menubar.add_cascade(label="View", menu=viewMenu)

    controlsMenu = Menu(menubar, tearoff=0)
    controlsMenu.add_command(label="Pause/Resume", command=pauseTests)
    controlsMenu.add_command(label="More Controls", command=openControls)
    menubar.add_cascade(label="Control", menu=controlsMenu)

    root.config(menu=menubar)

#Draws the screen with the current parameters
def update():
    global root
    global dataFrame
    global testIndexDict
    #apply appearance theme to main window
    T.apply([root, dataFrame, ver, botControl, pauseAllButton, resumeAllButton])
    verText.config(bg=T.theme.bg, fg=T.theme.fg, font=(T.family, T.size-2, "italic"))

    #forget all children in anticipation of reordering and redrawing them
    for child in dataFrame.winfo_children():
        child.grid_forget()
    placer = 0
    tests.sort(key=lambda x: x.testNum) #sort tests by test number/slave address
    testIndexDict = {} #reset dictonary
    for i in range(len(tests)):
        testIndexDict[tests[i].testNum] = i
        
        if tests[i].showTest:
            tests[i].draw(int(placer/10)+1, placer%10)
            placer += 1
    
    
    if not locked:
        fileMenu.entryconfig(0, label="Save Session", command=saveSession, state=NORMAL)
        fileMenu.entryconfig(1, label="Open Session", command=openSession, state=NORMAL)
        fileMenu.entryconfig(2, label="Connections", command=connect, state=NORMAL)
        fileMenu.entryconfig(3, label="Write to File", command=writeToFile, state=NORMAL)
        fileMenu.entryconfig(4, label="Exit", command=exitProgram, state=NORMAL)
        
        functionsMenu.entryconfig(0, label="Edit Stations", command=editTests, state=NORMAL)
        functionsMenu.entryconfig(1, label="Add Station", command=addTest, state=NORMAL)
        functionsMenu.entryconfig(2, label="Delete Station", command=deleteTest, state=NORMAL)
        functionsMenu.entryconfig(3, label="Label Controls", command=editControls, state=NORMAL)
        
        viewMenu.entryconfig(0, label="Hide/Show Stations", command=changeView, state=NORMAL)
        viewMenu.entryconfig(1, label="Theme", command=theme, state=NORMAL)
        viewMenu.delete(2)
        viewMenu.add_cascade(label="Lock Display", menu=lockSubMenu)
        
        controlsMenu.entryconfig(0, label="Pause/Resume", state=NORMAL)
        controlsMenu.entryconfig(1, label="More Controls", command=openControls, state=NORMAL)
        
        # testCommentsMenu.entryconfig(0, label="Add a Comment", command=addComment, state=NORMAL)
        # testCommentsMenu.entryconfig(1, label="View Comments", command=viewComments, state=NORMAL)
        
    else:
        fileMenu.entryconfig(0, label="Save Session", command=saveSession)
        fileMenu.entryconfig(1, label="Open Session", state=DISABLED)
        fileMenu.entryconfig(2, label="Connections", state=DISABLED)
        fileMenu.entryconfig(3, label="Write to File", command=writeToFile)
        fileMenu.entryconfig(4, label="Exit", command=exitProgram)
        
        functionsMenu.entryconfig(0, label="Edit Stations", state=DISABLED)
        functionsMenu.entryconfig(1, label="Add Station", state=DISABLED)
        functionsMenu.entryconfig(2, label="Delete Station", state=DISABLED)
        functionsMenu.entryconfig(3, label="Label Controls", state=DISABLED)
        
        viewMenu.entryconfig(0, label="Hide/Show Stations", state=DISABLED)
        viewMenu.entryconfig(1, label="Theme", command=theme)
        viewMenu.delete(2)
        viewMenu.add_command(label="Unlock Display", command=unlockDisplay)
        
        controlsMenu.entryconfig(0, label="Pause/Resume", state=DISABLED)
        controlsMenu.entryconfig(1, label="More Controls", state=DISABLED)
        
        # testCommentsMenu.entryconfig(0, label="Add a Comment", command=addComment)
        # testCommentsMenu.entryconfig(1, label="View Comments", command=viewComments)
        

    T.apply([fileMenu, functionsMenu, viewMenu, lockSubMenu, controlsMenu])
    # T.apply(testCommentsMenu)
    
    if locked or len(tests) == 0 or not poll.is_open():
        pauseAllButton.config(state=DISABLED)
        resumeAllButton.config(state=DISABLED)
    else:
        pauseAllButton.config(state=NORMAL)
        resumeAllButton.config(state=NORMAL)

    root.update_idletasks()
    root.geometry(str(max(root.winfo_reqwidth(),400))+'x'+str(max(root.winfo_reqheight(),300)))
    root.minsize(width=max(root.winfo_reqwidth(),400), height=max(root.winfo_reqheight(),300))


#API hosting block

#TODO: implement
class Server:
    def init(self, port=5000):
        self.api = flask.Flask(__name__, instance_relative_config=True)
        self.api.config.from_mapping(SECRET_KEY='dev')
        self.api.add_url_rule('/', 'manifest', self.manifest)
        self.api.add_url_rule('/index', 'index', self.index)
        self.api.add_url_rule('/station/<url>', 'serve station', self.serveStation)

        self.q = queue.Queue()

        self.running = False

    def manifest(self):
        return flask.json.jsonify({'app': 'Power Tools Test Manager', 'version': version})

    def index(self):
        return flask.json.jsonify([{
            "url": oo.url,
            "number": oo.testNum,
            "title": oo.name,
            "subtitle": oo.serial
            } for oo in tests])

    def serveStation(self, url):
        stationToServe = next([oo for oo in tests if oo.url == url], None)
        if not stationToServe is None:
            return flask.json.jsonify({
                "url": stationToServe.url,
                "number": stationToServe.testNum,
                "title": stationToServe.name,
                "subtitle": stationToServe.serial,
                "status": stationToServe.status, 
                "data": [{
                    "name": oo[0],
                    "units": oo[1],
                    "float": oo[2],
                    "show": oo[3]
                    }for oo in stationToServe.data],
                "controls": [{
                    "name": oo[0],
                    "data": oo[1]
                    }for oo in stationToServe.controls]
                })
        return

    def mainloop(self):
        pass

#TODO: find a way to host the api without interrupting the rest of the program

#PLC station polling object
#This object is used to control and execute all operations related to polling the serial network of PLCs.
#It is designed to be run in a separate thread, with mainloop() as the target.
#public methods are designed to be called from outside the thread running mainloop()
#most public methods automatically queue up operations to be executed within the mainloop().  They also automatically block until the the queue of operations is empty.
#private methods, with preceding underscores, are meant to be run from inside the mainloop().  They should not be called from outside.
#the loop is terminated by the destroy() method
class Polling:
    def __init__(self, port=None):
        #initialize serial connection configuration, without selecting a port.  ser will not open until ser.open() is called
        self.ser = serial.Serial(port=None, baudrate=38400, parity=serial.PARITY_ODD, stopbits=serial.STOPBITS_ONE, bytesize=serial.EIGHTBITS, timeout=serTimeout)
        self.ser.port = port
        #boolean value that tracks if the mainloop is in execution
        self.running = False
        #queue for enqueueing functions to be run in the mainloop
        self.q = queue.Queue()

    #Static helper Function getCRC()
    #when given a binary message as a list of ints, returns a 16 bit MODBUS Circular Redundancy Check as a list of ints.
    def getCRC(msg):
        CRC = 0xFFFF
        
        for bx in msg: 
            CRC ^= bx
            for ii in range(8):
                LSB = CRC & 0x0001 #extract LSB
                CRC >>= 1 #right shift
                if LSB == 1:
                    CRC ^= 0xA001 #xor per generation procedure

        return[(CRC & 0x00FF), (CRC >> 8)] # return CRC as a list of two ints, swapped per generation procedure

    #station control functions block

    #pass a test object to enqueue a pause command to be sent to the associated PLC slave address
    def pause(self, theTest):
        if not self.ser.is_open:
            messagebox.showerror("Power Tools Test Manager", "Not connected to a serial port", parent=root.focus_get())
        else:
            self.q.put(lambda self = self, slID = theTest.testNum: self._pause(slID))
            self.q.join()

    #private method enqueued by pause()
    def _pause(self, slID):
        if self.ser.is_open:
            msg = [
                slID, #slave ID
                0x05, #MODBUS Command (Force Single Coil)
                0x40, #Coil Address (C50)
                0x31,
                0xFF, #set ON
                0x00
            ]
            msg = msg + Polling.getCRC(msg) #append CRC
            self.ser.write(bytes(msg))
            sleep(serTimeout)
            self.ser.reset_input_buffer()

    #pass a test object to enqueue an unpause command to be sent to the associated PLC slave address
    def resume(self, theTest):
        if not self.ser.is_open:
            messagebox.showerror("Power Tools Test Manager", "Not connected to a serial port", parent=root.focus_get())
        else:
            self.q.put(lambda self=self, slID=theTest.testNum: self._resume(slID))
            self.q.join()

    #private method enqueued by resume()
    def _resume(self, slID):
        if self.ser.is_open:
            msg = [
                slID, #slave ID
                0x05, #MODBUS Command (Force Single Coil)
                0x40, #Coil Address (C50)
                0x31,
                0x00, #set OFF
                0x00
            ]
            msg = msg + Polling.getCRC(msg) #append CRC
            self.ser.write(bytes(msg))
            sleep(serTimeout)
            self.ser.reset_input_buffer()

    #pass a test object to enqueue a command to be sent to the associated PLC slave address
    #The passed boolean value will be assigned to the passed integer control index from 1-32
    def control(self, theTest, controlIndex, value):
        if not self.ser.is_open:
            messagebox.showerror("Power Tools Test Manager", "Not connected to a serial port", parent=root.focus_get())
        else:
            self.q.put(lambda self=self, slID=theTest.testNum, controlIndex=controlIndex, value=value: self._control(slID, controlIndex, value))
            self.q.join()

    #private method enqueued by control()
    def _control(self, slID, controlIndex, value):
        if self.ser.is_open:
            msg = [
                slID, #slave ID
                0x05, #MODBUS Command (Force Single Coil)
                0x40, #Coil Address (C101 - C132)
                (controlIndex + 0x63),
                (value*0xFF), #set ON (0xFF) or OFF (0x00)
                0x00
            ]
            msg = msg + Polling.getCRC(msg) #append CRC
            self.ser.write(bytes(msg))
            sleep(serTimeout)
            self.ser.reset_input_buffer()

    #enqueue a broadcast pause command to be sent to all PLCs on the network
    def pauseAll(self):
        if not self.ser.is_open:
            messagebox.showerror("Power Tools Test Manager", "Not connected to a serial port", parent=root.focus_get())
        else:
            self.q.put(lambda self=self: self._pauseAll())
            self.q.join()

    #private method enqueued by pauseAll()
    def _pauseAll(self):
        if self.ser.is_open:
            msg = [
                0x00, #address "0" to indicate a broadcast pause
                0x05, #MODBUS Command (Force Single Coil)
                0x40, #Coil Address (C50)
                0x31,
                0xFF, #set ON
                0x00
            ]
            msg = msg + Polling.getCRC(msg) #append CRC
            self.ser.write(bytes(msg))
            sleep(serTimeout)
            self.ser.reset_input_buffer()

    #enqueue a broadcast unpause command to be sent to all PLCs on the network
    def resumeAll(self):
        if not self.ser.is_open:
            messagebox.showerror("Power Tools Test Manager", "Not connected to a serial port", parent=root.focus_get())
        else:
            self.q.put(lambda self=self: self._resumeAll())
            self.q.join()

    #private method enqueued by resumeAll()
    def _resumeAll(self):
        if self.ser.is_open:
            msg = [
                0x00, #address "0" to indicate a broadcast pause
                0x05, #MODBUS Command (Force Single Coil)
                0x40, #Coil Address (C50)
                0x31,
                0x00, #set OFF
                0x00
            ]
            msg = msg + Polling.getCRC(msg) #append CRC
            self.ser.write(bytes(msg))
            sleep(serTimeout)
            self.ser.reset_input_buffer()

    #enque a request for a range of relevant floating point data values from the PLC associated with the passed Test object
    def retrieveData(self, theTest):
        if not self.ser.is_open:
            messagebox.showerror("Power Tools Test Manager", "Not connected to a serial port", parent=root.focus_get())
        else:
            self.q.put(lambda self=self, theTest=theTest: self._retrieveData(theTest))
            self.q.join()

    #_retrieveData, private method that will update the given test's data based on the results of __checkData
    #method enqueued by retrieveData()
    def _retrieveData(self, theTest):
        retryCount = 0 #set retry count to 0, communication will be attempted 3 times before setting the station as offline
        done = False #loop break condition
        if not theTest is None and theTest.testNum > 0 and theTest.testNum <= 247 and self.ser.is_open: #If test exists, has a valid slave ID, and serial port is connected
            while not done:
                try:
                    success, newData = self.__checkData(theTest.testNum)

                    if success: #ensure that all requests were successful
                            
                        theTest.set(newData)
                        done = True #exit upon success
                    else: 
                        retryCount += 1
                except serial.serialutil.SerialException: #handle case where serial port is unexpectedly disconnected during communication
                    self.close()
                    global tests
                    for oo in tests:
                        oo.setOffline()
                    done = True #exit upon error
                if retryCount >= 3: #If the same test has been polled three times, with no response or bad responses, set the test as offline and continue
                    theTest.setOffline()
                    done = True #exit upon 3 unsuccessful retries

    #__checkData(), accepts a MODBUS slave ID to poll
    #composes and sends a MODBUS command which will instruct the PLC to return its data registers DF101-132
    #reads the returned message and decodes to retrieve data
    #returns a 2-tuple containing a boolean and an array containing the new data
    #returns true is the data message is acceptable, returns false if it detects an error or an empty message
    def __checkData(self, slID):
        msg = [
            slID, #slave ID
            0x03, #MODBUS Command (Read Holding Registers)
            0x70, #Starting Address (DF101)
            0xC8,
            (numberOfData*2) // 0x100, #No. of points (64) (32 Floats)
            (numberOfData*2) % 0x100
        ]
        msg = msg + Polling.getCRC(msg) #append CRC
        self.ser.write(bytes(msg))

        b = self.ser.read(size=numberOfData*4+5)

        #parse binary response
        if b == b'':
            #print("Error, nothing returned, "+str(slID))
            return False, None
        
        if not len(b) == numberOfData*4+5: #133 bytes, 128 bytes for data (32x4 bytes/float) + 5
            #print("Error, incorrect length, length was "+str(len(b)))
            return False, None

        if not b[0] == slID: #slave ID
            #print("Error, wrong slID, slID was "+str(b[0])+", was polling "+str(slID))
            return False, None

        if not b[1] == 0x03: #MODBUS Command (Read Holding Registers)
            #print("Error, wrong command returned, command was "+str(b[1]))
            return False, None

        crc = Polling.getCRC(b[0:-2])
        if not [b[-2], b[-1]] == crc:
            #print("Error, wrong CRC returned, CRC was "+hex(b[131])+hex(b[132])+", calculated "+hex(crc[0])+hex(crc[1]))
            return False, None

        dataVals = []
        for ii in range(numberOfData):
            dataVals.append(unpack('>f',bytes([b[ii*4+5], b[ii*4+6], b[ii*4+3], b[ii*4+4]]))[0]) #ammend byteswapping, and convert from IEEE-754 to python float with unpack()
            
        return True, dataVals

    #enque a request for a range of relevant control coil boolean values from the PLC associated with the passed Test object
    def retrieveControls(self, theTest):
        if not self.ser.is_open:
            messagebox.showerror("Power Tools Test Manager", "Not connected to a serial port", parent=root.focus_get())
        else:
            self.q.put(lambda self=self, theTest=theTest: self._retrieveControls(theTest))
            self.q.join()

    #_retrieveControls, private method that will update the given test's controls based on the results of __checkControls()
    #method enqueud by retrieveControls()
    def _retrieveControls(self, theTest):
        retryCount = 0 #set retry count to 0, communication will be attempted 3 times before setting the station as offline
        done = False #loop break condition
        if not theTest is None and theTest.testNum > 0 and theTest.testNum <= 247 and self.ser.is_open: #If test exists, has a valid slave ID, and serial port is connected
            while not done:
                try:
                    success, contStatus = self.__checkControls(theTest.testNum)

                    if success: #ensure that request was successful
                        theTest.setControlStatus(contStatus)
                        done = True #exit upon success
                    else: 
                        retryCount += 1
                except serial.serialutil.SerialException: #handle case where serial port is unexpectedly disconnected during communication
                    self.close()
                    global tests
                    for oo in tests:
                        oo.setOffline()
                    done = True #exit upon error
                if retryCount >= 3: #If the same test has been polled three times, with no response or bad responses, set the test as offline and continue
                    theTest.setOffline()
                    done = True #exit upon 3 unsuccessful retries

    #retrieveControlStatus, accepts a MODBUS slave ID to poll
    #composes and sends a MODBUS command which will instruct the PLC to return its control coils C101-132
    #reads the returned message and decodes to retrieve data
    #returns a 2-tuple containing a boolean and an array containing the new data
    #returns true is the data message is acceptable, returns false if it detects an error or an empty message
    def __checkControls(self, slID):
        msg = [
            slID, #slave ID
            0x01, #MODBUS Command (Read Coil Status)
            0x40, #Starting Address (C101)
            0x64,
            numberOfControls // 0x100, #No. of points (32) (32 Coils)
            numberOfControls % 0x100
        ]
        msg = msg + Polling.getCRC(msg) #append CRC
        self.ser.write(bytes(msg))

        b = self.ser.read(size=-(-numberOfControls//8)+5) #upside down floor division does ceiling division

        #parse binary response
        if b == b'':
            #print("Error, nothing returned, "+str(slID))
            return False, None
        
        if not len(b) == -(-numberOfControls//8)+5: #9 bytes, 4 bytes for data (32/8 coils/byte) + 5
            #print("Error, incorrect length, length was "+str(len(b)))
            return False, None

        if not b[0] == slID: #slave ID
            #print("Error, wrong slID, slID was "+str(b[0])+", was polling "+str(slID))
            return False, None

        if not b[1] == 0x01: #MODBUS Command (Read Coil Status)
            #print("Error, wrong command returned, command was "+str(b[1]))
            return False, None

        crc = Polling.getCRC(b[0:-2])
        if not [b[-2], b[-1]] == crc:
            #print("Error, wrong CRC returned, CRC was "+hex(b[131])+hex(b[132])+", calculated "+hex(crc[0])+hex(crc[1]))
            return False, None

        dataVals = []
        for ii in range(numberOfControls):
            dataVals.append(bool((b[ii//8+3]) & (0x1 << ii%8))) #ammend bit ordering, and convert to a list of booleans
            
        return True, dataVals

    #enque a request for the state of the PLC associated with the passed Test object
    def retrieveStatus(self, theTest):
        if not self.ser.is_open:
            messagebox.showerror("Power Tools Test Manager", "Not connected to a serial port", parent=root.focus_get())
        else:
            self.q.put(lambda self=self, theTest = theTest: self._retrieveStatus(theTest))
            self.q.join()

    #_retrieveStatus, private method that will update the given test's status based on the results of __checkIfPaused and __checkIfRunning
    #method enqueued by retrieveStatus()
    def _retrieveStatus(self, theTest):
        retryCount = 0 #set retry count to 0, communication will be attempted 3 times before setting the station as offline
        done = False #loop break condition
        if not theTest is None and theTest.testNum > 0 and theTest.testNum <= 247 and self.ser.is_open: #If test exists, has a valid slave ID, and serial port is connected
            while not done:
                try:
                    pSuccess, isPaused = self.__checkIfPaused(theTest.testNum)
                    rSuccess, isRunning = self.__checkIfRunning(theTest.testNum)

                    if pSuccess and rSuccess: #ensure that all requests were successful
                        #update test status based on results
                        if not isRunning:
                            theTest.setStopped()
                        elif isPaused:
                            theTest.setPaused()
                        else:
                            theTest.setNormal()
                        done = True #exit upon success
                    else: 
                        retryCount += 1
                except serial.serialutil.SerialException: #handle case where serial port is unexpectedly disconnected during communication
                    self.close()
                    global tests
                    for oo in tests:
                        oo.setOffline()
                    done = True #exit upon error
                if retryCount >= 3: #If the same test has been polled three times, with no response or bad responses, set the test as offline and continue

                    theTest.setOffline()
                    done = True #exit upon 3 unsuccessful retries

    #checkIfPaused(), accepts a MODBUS slave ID to poll.
    #composes a MODBUS command which will instruct the PLC to return the state of it's C50 register.
    #then parses the returned message, returning a 2-tuple
    #first value will return True if the response is acceptable, returns False if it detects an erroneous or empty message
    #second value returns True if the PLC is paused, False if not Paused, None otherwise
    #may raise SerialException
    def __checkIfPaused(self, slID):
        msg = [
            slID, #slave ID
            0x01, #MODBUS Command (Read Coil Status)
            0x40, #Starting Address (C50) (Pause)
            0x31,
            0x00, #No. of points (1) (1 Coil)
            0x01
        ]
        msg = msg + Polling.getCRC(msg) #append CRC
        self.ser.write(bytes(msg))

        b = self.ser.read(size=6)

        #parse binary response
        if b == b'':
            #print("Error, nothing returned, address was"+str(slID))
            return False, None

        if not len(b) == 6: #6 bytes, 1 bytes for data + 5
            #print("Error, incorrect length, length was "+str(len(b)))
            return False, None

        if not b[0] == slID: #slave ID
            #print("Error, wrong slID, slID was "+str(b[0])+", was polling "+str(slID))
            return False, None

        if not b[1] == 0x01: #MODBUS Command (Read Coil Status)
            #print("Error, wrong command returned, command was "+hex(b[1])+", expected 0x01")
            return False, None

        if not b[2] == 0x01: #Num data bytes (1)
            #print("Error, incorrect byte count reported, "+str(b[2])+", expected 1")
            return False, None

        crc = Polling.getCRC(b[0:4])
        if not [b[4], b[5]] == crc:
            #print("Error, wrong CRC returned, CRC was "+hex(b[4])+hex(b[5])+", calculated "+hex(crc[0])+hex(crc[1]))
            return False, None

        if b[3] == 0x01: #C50 is set, test is paused
            return True, True
        elif b[3] == 0x00: #C50 is reset, test is not paused
            return True, False
        else:
            #print("Error, value recieved was neither true or false, recieved "+hex(b[3]))
            return False, None
        
    #checkIfRunning(), accepts a MODBUS slave ID to poll.
    #composes a MODBUS command which will instruct the PLC to return the state of it's SC11 register.
    #then parses the returned message, returning a 2-tuple
    #first value will return True if the response is acceptable, returns False if it detects an erroneous or empty message
    #second value returns True if the PLC is in run mode, False if in stop mode, None otherwise
    #may raise SerialException
    def __checkIfRunning(self, slID):
        msg = [
            slID, #slave ID
            0x02, #MODBUS Command (Read Input Status)
            0xF0, #Starting Address (SC11) (_PLC_Mode)
            0x0A,
            0x00, #No. of points (1) (1 Coils)
            0x01
        ]
        msg = msg + Polling.getCRC(msg) #append CRC
        self.ser.write(bytes(msg))

        b = self.ser.read(size=6)

        #parse binary response
        if b == b'':
            #print("Error, nothing returned, address was"+str(slID))
            return False, None

        if not len(b) == 6: #6 bytes, 1 bytes for data + 5
            #print("Error, incorrect length, length was "+str(len(b)))
            return False, None

        if not b[0] == slID: #slave ID
            #print("Error, wrong slID, slID was "+str(b[0])+", was polling "+str(slID))
            return False, None

        if not b[1] == 0x02: #MODBUS Command (Read Input Status)
            #print("Error, wrong command returned, command was "+hex(b[1])+", expected 0x01")
            return False, None

        if not b[2] == 0x01: #Num data bytes (1)
            #print("Error, incorrect byte count reported, "+str(b[2])+", expected 1")
            return False, None

        crc = Polling.getCRC(b[0:4])
        if not [b[4], b[5]] == crc:
            #print("Error, wrong CRC returned, CRC was "+hex(b[4])+hex(b[5])+", calculated "+hex(crc[0])+hex(crc[1]))
            return False, None

        if b[3] == 0x01: #SC11 is set, PLC is in Run mode
            return True, True
        elif b[3] == 0x00: #SC11 is reset, PLC is in Stop mode
            return True, False
        else:
            #print("Error, value received was neither true or false, received "+hex(b[3]))
            return False, None

    #main loop for receiving checking up and receiving from PLCs and continuing the GUI #TODO: application crashes when serial connection is physically terminated during runtime
    def mainloop(self):
        global tests
        self.running = True
        currentTestIndex = 0 #Index in tests of the next station to be polled during regular polling
        #if the loop encounters an error while parsing three times in a row, it will mark the test as offline and proceed to poll the next test
        while(self.running): 
            while not self.q.empty():
                job = self.q.get_nowait()
                job() #perform the queued function
                self.q.task_done() #flag that the queued task has finished to release other blocking threads
            else:
                sleep(serTimeout) #sleeping here for a beat gives joined threads the time to release blocking
                if self.ser.is_open and len(tests) > 0:
                    if currentTestIndex >= len(tests):
                        currentTestIndex = 0
                    #enqueue regular polling tasks
                    self.q.put(lambda self=self, theTest=tests[currentTestIndex]: self._retrieveStatus(theTest))
                    self.q.put(lambda self=self, theTest=tests[currentTestIndex]: self._retrieveData(theTest))
                    self.q.put(lambda self=self, theTest=tests[currentTestIndex]: self._retrieveControls(theTest))
                    currentTestIndex += 1

    #pass an int to enqueue a directive to change the COM port
    def change_port(self, newPort):
        self.q.put(lambda self=self, newPort=newPort: self._change_port(newPort))
        self.q.join()

    #method enqueud by change_port()
    def _change_port(self, newPort):
        try:
            self.ser.port = 'COM%s' % newPort
        except serial.serialutil.SerialException:
            self.ser.close()

    #enqueue a directive to enable serial communication
    def open(self):
        if not self.ser.is_open:
            self.q.put(lambda self=self: self._open())
            self.q.join()

    #method enqued by open()
    def _open(self):
        if not self.ser.is_open:
            try:
                self.ser.open()
            except serial.serialutil.SerialException as e:
                self.ser.close()

    #enqueue a directive to disable serial communucation
    def close(self):
        if self.ser.is_open:
            self.q.put(lambda self=self: self._close())
            self.q.join()

    #method enqueued by close()
    def _close(self):
        if self.ser.is_open:
            self.ser.close()
        for oo in tests:
            oo.setOffline()

    #destructor that will end the main loop.  Free to be called from anywhere in the program
    def destroy(self):
        self.close()
        self.running = False

    #returns whether a serial connection is open.  Free to be called from anywhere in the program
    def is_open(self):
        return self.ser.is_open

#main
if __name__ == "__main__":
    #draw the main viewer
    root = Tk()
    favicon = PhotoImage(data=encoded_string)
    root.iconphoto(True, favicon) #sets the favicon for root and all toplevel()
    root.title('Power Tools Test Manager')
    root.protocol('WM_DELETE_WINDOW', exitProgram) #Override close button with exitProgram, defined above

    #keep track of if the software is locked, if it is locked by password, and the password itself
    locked = False
    passlocked = False
    password = ""

    #create an empty list, to be filled with user-specified Theme objects from the themes.json config file.  Population occurs in startup configuration phase
    themes = []
    #create an empty list, to be filled with user-specified fonts from the fonts.json config file.  Population occurs in startup configuration phase
    families = []
    #create an empty list, to be filled with user-specified text sizes from the fonts.json config file.  Population occurs in startup configuration phase
    sizes = []

    #create a ThemeAndFont object, which will be used use to paint the program
    T = tkTheme.ThemeAndFont()
    #list which holds the array of tests, currently begins empty
    tests = []
    #Dictionary which will be used to link address to index in tests[]
    testIndexDict = {}

    #Polling object, which controls and executes all operations related to polling the serial network
    poll = Polling()
    #list of all threads
    threads = []
    threads.append(threading.Thread(target=poll.mainloop))
    for oo in threads:
        oo.start()

    #draw screen for the first time
    buildWindow()

    #startup configuration block

    #add all themes from themes configuration file
    try:
        themefile = json.load(open("themes.json"))
        #expects a list of JSON objects with attributes that can be used to initialize Theme objects
        for kwargs in themefile:
            themes.append(tkTheme.Theme(**kwargs))

    except Exception as e:
        messagebox.showerror("Power Tools Test Viewer", "Problem encountered while loading from themes file", parent=root.focus_get())
    finally:
        if len(themes) == 0:
            themes.append(T.theme) #default theme

    #add all font options from font configuration file
    try:
        fontsfile = json.load(open("fonts.json"))
        #expects a list of font family names
        if "families" in fontsfile:
            if isinstance(fontsfile["families"], list):
                families.extend([oo for oo in fontsfile["families"] if oo in tkinter.font.families()])

        #expects a list of integer sizes
        if "sizes" in fontsfile:
            if isinstance(fontsfile["sizes"], list):
                sizes.extend([oo for oo in fontsfile["sizes"] if isinstance(oo, int)])

    except Exception as e:
        raise
        messagebox.showerror("Power Tools Test Viewer", "Problem encountered while loading from fonts file", parent=root.focus_get())
    finally:
        if len(families) == 0:
            families.append(T.family) #default font family
        if len(sizes) == 0:
            sizes.append(T.size) #default font size

    #configure from config file on startup
    try:
        conf = json.load(open("config.json"))

        #connect to a COM port on startup.  "port" accepts a value between 1 and 256, in the form of an int or a string "COM<value>"
        if "port" in conf:
            if isinstance(conf["port"], str):
                if len(conf["port"]) > 3:
                    if conf["port"][:3] == "COM" and conf["port"][3:].isdigit():
                        conf["port"] = int(conf["port"][3:])

            if isinstance(conf["port"], int):
                if conf["port"] > 0 and conf["port"] <= 256:
                    poll.change_port(conf["port"])
                    poll.open()

        #open one or more session files on startup.  "file" accepts a string filepath, or a list of string filepaths
        if "file" in conf:
            if isinstance(conf["file"], str):
                conf["file"] = [conf["file"]]
            if isinstance(conf["file"], list):
                for oo in conf["file"]:
                    if isinstance(oo, str):
                        if os.path.isfile(oo):
                            try:
                                tests.extend(parseJSONsession(json.load(open(oo))))
                            except Exception as e:
                                pass

        #locks the display on startup. "lock" accepts a boolean value, which locks the screen if true.  "pass" accepts a string value, which sets the password
        if "lock" in conf:
            if isinstance(conf["lock"], bool):
                if conf["lock"]:
                    locked = True
                    if "pass" in conf:
                        if isinstance(conf["pass"], str):
                            passlocked = True
                            password = conf["pass"]
                    
        #sets the display theme on startup.  "theme" accepts a string value.  If the value matches the name of a loaded theme, that theme will be selected, otherwise it will select the first loaded theme
        if "theme" in conf:
            if isinstance(conf['theme'], str):
                T.set(theme=next((oo for oo in themes if oo.title == conf['theme']), themes[0]))

        #sets the font family on startup.  "fontFamily" accepts a string value.  If the value is the name of a tkinter supported font, that font will be selected
        if "fontFamily" in conf:
            if conf["fontFamily"] in tkinter.font.families():
                T.set(family=conf["fontFamily"])

        #sets the font size on startup.  "fontSize" accepts an integer value to use as the size of the font
        if "fontSize" in conf:
            if isinstance(conf["fontSize"], int):
                T.set(size=conf["fontSize"])

    except Exception as e:
        messagebox.showerror("Power Tools Test Viewer", "Problem encountered while loading from config file", parent=root.focus_get())

    
    #update the display for the first time
    update()

    root.mainloop() #Tkinter main thread